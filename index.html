<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=yes, initial-scale=1, maximum-scale=4">	
<meta name="description" content="This program is the JavaScript port of pwgen.">
<meta name="application-name" content="pwgen">
<meta name="author" content="hachisukansw">
<!--
NAME
		pwgen - generate pronounceable passwords
 
SYNOPSIS
		pwgen [ OPTION ] [ pw_length ] [ num_pw ]
 
DESCRIPTION
		The  pwgen  program generates passwords which are designed to be easily
		memorized by humans, while being as secure  as  possible.   Human-memo‐
		rable  passwords  are  never  going  to be as secure as completely com‐
		pletely random passwords.  In particular, passwords generated by  pwgen
		without  the  -s option should not be used in places where the password
		could be attacked via an off-line brute-force attack.    On  the  other
		hand,  completely  randomly  generated  passwords have a tendency to be
		written down, and are subject to being compromised in that fashion.
 
		The pwgen program is designed to be used  both  interactively,  and  in
		shell  scripts.   Hence,  its  default  behavior  differs  depending on
		whether the standard output is a tty device or a pipe to  another  pro‐
		gram.  Used interactively, pwgen will display a screenful of passwords,
		allowing the user to pick a single password, and then quickly erase the
		screen.   This  prevents someone from being able to "shoulder surf" the
		user's chosen password.
 
		When standard output (stdout) is not a tty, pwgen  will  only  generate
		one  password,  as  this  tends  to  be  much more convenient for shell
		scripts, and in order to be compatible with previous versions  of  this
		program.
 
OPTIONS
		-0, --no-numerals
			   Don't include numbers in the generated passwords.
 
		-1     Print the generated passwords one per line.
 
		-A, --no-capitalize
			   Don't  bother  to  include  any capital letters in the generated
			   passwords.
 
		-a, --alt-phonics
			   This option doesn't do anything special; it is present only  for
			   backwards compatibility.
 
		-B, --ambiguous
			   Don't  use  characters  that  could be confused by the user when
			   printed, such as 'l' and '1', or '0' or 'O'.  This  reduces  the
			   number  of possible passwords significantly, and as such reduces
			   the quality of the passwords.  It may be useful  for  users  who
			   have bad vision, but in general use of this option is not recom‐
			   mended.
 
		-c, --capitalize
			   Include at least one capital letter in the  password.   This  is
			   the default if the standard output is a tty device.
 
		-C     Print  the  generated passwords in columns.  This is the default
			   if the standard output is a tty device.
 
		-N, --num-passwords=num
			   Generate num passwords.  This defaults to a screenful  if  pass‐
			   words are printed by columns, and one password otherwise.
 
		-n, --numerals
			   Include  at  least  one  number  in  the  password.  This is the
			   default if the standard output is a tty device.
 
		-H, --sha1=text[:seed]
			   Will use the sha1's hash of given file and the optional seed  to
			   create  password. It will allow you to compute the same password
			   later, if you remember the file, seed, and pwgen's options used.
			   ie:  pwgen?-H=your_favorite:your@email.com gives a list of
			   possibles passwords for your pop3 account, and you can ask  this
			   list again and again.
 
			   WARNING:  The passwords generated using this option are not very
			   random.  If you use this option, make sure the attacker can  not
			   obtain a copy of the file.  Also, note that the name of the file
			   may be easily available from the ~/.history  or  ~/.bash_history
			   file.
 
		-h, --help
			   Print a help message.
 
		-r chars, --remove-chars=chars
			   Don't  use  the  specified  characters in password.  This option
			   will disable the phomeme-based generator  and  uses  the  random
			   password generator.
 
		-s, --secure
			   Generate  completely  random, hard-to-memorize passwords.  These
			   should only be used for machine passwords, since otherwise  it's
			   almost guaranteed that users will simply write the password on a
			   piece of paper taped to the monitor...
 
		-v, --no-vowels
			   Generate random passwords that do not contain vowels or  numbers
			   that  might  be  mistaken  for  vowels.  It provides less secure
			   passwords to allow system administrators to not  have  to  worry
			   with random passwords accidentally contain offensive substrings.
 
		-y, --symbols
			   Include at least one special character in the password.

		-u, -uniq
			Generate a unique password list.
		
		-L, --length
			password length. This defaults is 8.

AUTHOR
		This    version    of    pwgen    was    written   by   Theodore   Ts'o
		<tytso@alum.mit.edu>.  It is modelled after a program originally  writ‐
		ten  by Brandon S. Allbery, and then later extensively modified by Olaf
		Titz,  Jim Lynch,  and  others.   It  was  rewritten  from  scratch  by
		Theodore  Ts'o because the original program was somewhat of a hack, and
		thus hard to maintain, and because the licensing status of the  program
		was unclear.
 
SEE ALSO
		passwd(1)
 
 
 
pwgen version 2.08                August 2017                         PWGEN(1)
-->
<style type="text/css">
html,body {
	height: calc(100% - 8px);
	margin: 0px;
	padding: 4px;
	border: none;
}
* {
	font-family: monospace, 'Courier New', Consolas;
    font-size: 16px;
	letter-spacing: 0px;
	background-color: white;
	color: black;
	-webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    border-radius: 0px;
}
a {
	text-decoration: none;
}
input[type="text"] {
	width: 2em;
	margin-left: 0.5em;
    font-size: 14px;
	border: 1px solid silver;
	color: silver;
}
input[type="checkbox"] {
	display: none;
}
label {
	color: silver;
}
label::before {
	content: "[ ]";
}
input[type="checkbox"]:checked + label {
	color: black;
}
input[type="checkbox"]:checked + label::before {
	content: "[X]";
}
input[type="checkbox"]:checked + label + input[type="text"] {
	color: black;
	border: 1px solid black;
}
#options {
	margin: 0.5em;
	padding-bottom: 0px;
	color: silver;
}
#result {
	box-sizing: border-box;
	width: 100%;
	height: 25em;
	overflow-x: hidden;
	overflow-y: auto;
	padding: 0.25em;
	border: 1px solid gray;
	background-color: whitesmoke;
	margin: 0px;
	word-wrap: normal;
}
#status {
	margin: 0px;
}
</style>
</head>
<body>
pwgen - generate pronounceable passwords<br />
<p id="options">
<input type="checkbox" id="-0"><label for="-0">0</label>
<input type="checkbox" id="-1"><label for="-1">1</label>
<input type="checkbox" id="-A"><label for="-A">A</label>
<input type="checkbox" id="-a"><label for="-a">a</label>
<input type="checkbox" id="-B"><label for="-B">B</label>
<input type="checkbox" id="-C"><label for="-C">C</label>
<input type="checkbox" id="-c"><label for="-c">c</label>
<input type="checkbox" id="-n"><label for="-n">n</label>
<input type="checkbox" id="-N"><label for="-N">N</label><input type="text" id="-N_txt">
<input type="checkbox" id="-s"><label for="-s">s</label>
<input type="checkbox" id="-r"><label for="-r">r</label><input type="text" id="-r_txt">
<input type="checkbox" id="-h"><label for="-h">h</label>
<input type="checkbox" id="-H"><label for="-H">H</label><input type="text" id="-H_txt">
<input type="checkbox" id="-v"><label for="-v">v</label>
<input type="checkbox" id="-y"><label for="-y">y</label>
<input type="checkbox" id="-L"><label for="-L">length</label><input type="text" id="-L_txt">
 | <a href="javascript:void(0)" id="refresh">refresh</a>
</p>
<textarea id="result" spellcheck="false"></textarea>
<pre id="status"></pre>
<p id="extoptions">
<input type="checkbox" id="--uniq"><label for="--uniq">uniq</label>
<input type="checkbox" id="--grep-upper"><label for="--grep-upper">grep[A-Z]</label>
<input type="checkbox" id="--grep-lower"><label for="--grep-lower">grep[a-z]</label>
<input type="checkbox" id="--grep-digit"><label for="--grep-digit">grep[0-9]</label>
<input type="checkbox" id="--grep-punct"><label for="--grep-punct">grep[[:punct:]]</label>
</p>
</body>
<script>
'use strict'

//------------------------------------------------------------------------
/*
 * This program is the JavaScript port of "pwgen.h".
 * Copyright (C) 2018 hachisukansw
 *
 * pwgen.h --- header file for password generator
 *
 * Copyright (C) 2001,2002 by Theodore Ts'o
 * 
 * This file may be distributed under the terms of the GNU Public
 * License.
 */
/*
 * Flags for the pw_element
 */
const CONSONANT	= 0x0001
const VOWEL		= 0x0002
const DIPTHONG	= 0x0004
const NOT_FIRST	= 0x0008
/*
 * Flags for the pwgen function
 */
const PW_DIGITS		= 0x0001	/* At least one digit */
const PW_UPPERS		= 0x0002	/* At least one upper letter */
const PW_SYMBOLS	= 0x0004
const PW_AMBIGUOUS	= 0x0008
const PW_NO_VOWELS	= 0x0010

//------------------------------------------------------------------------
/*
 * This program is the JavaScript port of "pw_rand.c".
 * Copyright (C) 2018 hachisukansw
 *
 * pw_rand.c --- generate completely random (and hard to remember)
 * 	passwords
 *
 * Copyright (C) 2001,2002 by Theodore Ts'o
 * 
 * This file may be distributed under the terms of the GNU Public
 * License.
 */
const pw_digits = "0123456789";
const pw_uppers = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
const pw_lowers = "abcdefghijklmnopqrstuvwxyz";
const pw_symbols = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
const pw_ambiguous = "B8G6I1l0OQDS5Z2";
const pw_vowels = "01aeiouyAEIOUY";

function remove_chars(buf, remove)
{
	return buf.split("").filter(s=>(!remove.includes(s))).join("");
}

function find_chars(buf, set)
{
	return buf.split("").filter(s=>(set.includes(s))).length>0;
}

function pw_rand(size, pw_flags, remove, pw_number)
{
	if (arguments.length == 1) {
		size = arguments[0].pw_length;
		pw_flags = arguments[0].pwgen_flags;
		remove = arguments[0].remove_chars;
		pw_number = arguments[0].pw_number;
	}

	let chars = "";
	if (pw_flags & PW_DIGITS) {
		chars += pw_digits;
	}
	if (pw_flags & PW_UPPERS) {
		chars += pw_uppers;
	}
	chars += pw_lowers;
	if (pw_flags & PW_SYMBOLS) {
		chars += pw_symbols;
	}
	if (remove) {
		if (pw_flags & PW_AMBIGUOUS)
			chars = remove_chars(chars, pw_ambiguous);
		if (pw_flags & PW_NO_VOWELS)
			chars = remove_chars(chars, pw_vowels);
		chars = remove_chars(chars, remove);
		if ((pw_flags & PW_DIGITS) &&
		    !find_chars(chars, pw_digits)) {
			console.log(
				"Error: No digits left in the valid set\n");
			return "";
		}
		if ((pw_flags & PW_UPPERS) &&
		    !find_chars(chars, pw_uppers)) {
			console.log(
				"Error: No upper case letters left in " + 
				"the valid set\n");
			return "";
		}
		if ((pw_flags & PW_SYMBOLS) &&
		    !find_chars(chars, pw_symbols)) {
			console.log(stderr,
				"Error: No symbols left in the valid set\n");
			return "";
		}
	}
	let len = chars.length;
	let feature_flags;
	let buf;
try_again:
	do {
		feature_flags = (size > 2) ? pw_flags : 0;
		buf = []
		while (buf.length < size) {
			let ch = chars[pw_number(len)];
			if ((pw_flags & PW_AMBIGUOUS) && pw_ambiguous.includes(ch))
				continue;
			if ((pw_flags & PW_NO_VOWELS) && pw_vowels.includes(ch))
				continue;
			buf.push(ch);
			if ((feature_flags & PW_DIGITS) &&
				pw_digits.includes(ch))
				feature_flags &= ~PW_DIGITS;
			if ((feature_flags & PW_UPPERS) &&
				pw_uppers.includes(ch))
				feature_flags &= ~PW_UPPERS;
			if ((feature_flags & PW_SYMBOLS) &&
				pw_symbols.includes(ch))
				feature_flags &= ~PW_SYMBOLS;
		}
	} while (feature_flags & (PW_UPPERS | PW_DIGITS | PW_SYMBOLS))
	return buf.join("");
}	

//------------------------------------------------------------------------
/*
 * This program is the JavaScript port of "pw_phonemes.c".
 * Copyright (C) 2018 hachisukansw
 *
 * pw_phonemes.c --- generate secure passwords using phoneme rules
 *
 * Copyright (C) 2001,2002 by Theodore Ts'o
 * 
 * This file may be distributed under the terms of the GNU Public
 * License.
 */

const elements = [
	{ str:"a",	 flags:VOWEL },
	{ str:"ae",	 flags:VOWEL | DIPTHONG },
	{ str:"ah",	 flags:VOWEL | DIPTHONG },
	{ str:"ai",	 flags:VOWEL | DIPTHONG },
	{ str:"b",	 flags: CONSONANT },
	{ str:"c",	 flags:CONSONANT },
	{ str:"ch",	 flags:CONSONANT | DIPTHONG },
	{ str:"d",	 flags:CONSONANT },
	{ str:"e",	 flags:VOWEL },
	{ str:"ee",	 flags:VOWEL | DIPTHONG },
	{ str:"ei",	 flags:VOWEL | DIPTHONG },
	{ str:"f",	 flags:CONSONANT },
	{ str:"g",	 flags:CONSONANT },
	{ str:"gh",	 flags:CONSONANT | DIPTHONG | NOT_FIRST },
	{ str:"h",	 flags:CONSONANT },
	{ str:"i",	 flags:VOWEL },
	{ str:"ie",	 flags:VOWEL | DIPTHONG },
	{ str:"j",	 flags:CONSONANT },
	{ str:"k",	 flags:CONSONANT },
	{ str:"l",	 flags:CONSONANT },
	{ str:"m",	 flags:CONSONANT },
	{ str:"n",	 flags:CONSONANT },
	{ str:"ng",	 flags:CONSONANT | DIPTHONG | NOT_FIRST },
	{ str:"o",	 flags:VOWEL },
	{ str:"oh",	 flags:VOWEL | DIPTHONG },
	{ str:"oo",	 flags:VOWEL | DIPTHONG},
	{ str:"p",	 flags:CONSONANT },
	{ str:"ph",	 flags:CONSONANT | DIPTHONG },
	{ str:"qu",	 flags:CONSONANT | DIPTHONG},
	{ str:"r",	 flags:CONSONANT },
	{ str:"s",	 flags:CONSONANT },
	{ str:"sh",	 flags:CONSONANT | DIPTHONG},
	{ str:"t",	 flags:CONSONANT },
	{ str:"th",	 flags:CONSONANT | DIPTHONG},
	{ str:"u",	 flags:VOWEL },
	{ str:"v",	 flags:CONSONANT },
	{ str:"w",	 flags:CONSONANT },
	{ str:"x",	 flags:CONSONANT },
	{ str:"y",	 flags:CONSONANT },
	{ str:"z",	 flags:CONSONANT }
];

const NUM_ELEMENTS = elements.length;

function pw_phonemes(size, pw_flags, remove, pw_number)
{
	if (arguments.length == 1) {
		size = arguments[0].pw_length;
		pw_flags = arguments[0].pwgen_flags;
		remove = arguments[0].remove_chars;
		pw_number = arguments[0].pw_number;
	}

	let		feature_flags;
	let		ch;
	let		buf = [];

try_again:
	do {
		feature_flags = pw_flags;
		let c = 0;
		let prev = 0;
		let should_be = 0;
		let first = 1;

		should_be = pw_number(2) ? VOWEL : CONSONANT;
		
		while (c < size) {
			let i = pw_number(NUM_ELEMENTS);
			let str = elements[i].str;
			let len = str.length;
			let flags = elements[i].flags;
			/* Filter on the basic type of the next element */
			if ((flags & should_be) == 0)
				continue;
			/* Handle the NOT_FIRST flag */
			if (first && (flags & NOT_FIRST))
				continue;
			/* Don't allow VOWEL followed a Vowel/Dipthong pair */
			if ((prev & VOWEL) && (flags & VOWEL) &&
				(flags & DIPTHONG))
				continue;
			/* Don't allow us to overflow the buffer */
			if (len > size-c)
				continue;

			/*
			* OK, we found an element which matches our criteria,
			* let's do it!
			*/
			for(let j=0;j<str.length;j++) {
				buf[c+j] = str[j];
			}

			/* Handle PW_UPPERS */
			if (pw_flags & PW_UPPERS) {
				if ((first || flags & CONSONANT) &&
					(pw_number(10) < 2)) {
					buf[c] = buf[c].toUpperCase();
					feature_flags &= ~PW_UPPERS; //
				}
			}

			/* Handle the AMBIGUOUS flag */
			if (pw_flags & PW_AMBIGUOUS) {
				buf.length = c + len; /* To make strpbrk() happy */
				if (buf.filter(s=>(pw_ambiguous.includes(s))).length > 0)
						continue;
			}

			c += len;
			
			/* Time to stop? */
			if (c >= size)
				break;
			
			/*
			* Handle PW_DIGITS
			*/
			if (pw_flags & PW_DIGITS) {
				if (!first && (pw_number(10) < 3)) {
					do {
						ch = pw_number(10).toString();
					} while ((pw_flags & PW_AMBIGUOUS) 
						&& pw_ambiguous.includes(ch));
					buf[c++] = ch;
					buf.length = c;
					feature_flags &= ~PW_DIGITS;
					
					first = 1;
					prev = 0;
					should_be = pw_number(2) ?
						VOWEL : CONSONANT;
					continue;
				}
			}
			
			/* Handle PW_SYMBOLS */
			if (pw_flags & PW_SYMBOLS) {
				if (!first && (pw_number(10) < 2)) {
					do {
						ch = pw_symbols[
							pw_number(pw_symbols.length)];
					} while ((pw_flags & PW_AMBIGUOUS) 
						&& pw_ambiguous.includes(ch));
					buf[c++] = ch;
					buf.length = c;
					feature_flags &= ~PW_SYMBOLS;
				}
			}

			/*
			* OK, figure out what the next element should be
			*/
			if (should_be == CONSONANT) {
				should_be = VOWEL;
			} else { /* should_be == VOWEL */
				if ((prev & VOWEL) ||
					(flags & DIPTHONG) ||
					(pw_number(10) > 3))
					should_be = CONSONANT;
				else
					should_be = VOWEL;
			}
			prev = flags;
			first = 0;
		}
	} while (feature_flags & (PW_UPPERS | PW_DIGITS | PW_SYMBOLS))
	return buf.join("");
}

//------------------------------------------------------------------------
/*
 * This program is the JavaScript port of "SHA-1 demonstration code in rfc1394".
 * Copyright (C) 2018 hachisukansw
 *
*/

//------------------------------------------------------------------------
/*
 *  sha1.h
 *
 *  Description:
 *      This is the header file for code which implements the Secure
 *      Hashing Algorithm 1 as defined in FIPS PUB 180-1 published
 *      April 17, 1995.
 *
 *      Many of the variable names in this code, especially the
 *      single character names, were used because those were the names
 *      used in the publication.
 *
 *      Please read the file sha1.c for more information.
 *
 */
const   shaSuccess = 0,
        shaNull = 1,            /* Null pointer parameter */
        shaInputTooLong = 2 ,    /* input data too long */
        shaStateError = 3      /* called Input after Result */
const   SHA1HashSize = 20;

//------------------------------------------------------------------------
/*
 *  sha1.c
 *
 *  Description:
 *      This file implements the Secure Hashing Algorithm 1 as
 *      defined in FIPS PUB 180-1 published April 17, 1995.
 *
 *      The SHA-1, produces a 160-bit message digest for a given
 *      data stream.  It should take about 2**n steps to find a
 *      message with the same digest as a given message and
 *      2**(n/2) to find any two messages with the same digest,
 *      when n is the digest size in bits.  Therefore, this
 *      algorithm can serve as a means of providing a
 *      "fingerprint" for a message.
 *
 *  Portability Issues:
 *      SHA-1 is defined in terms of 32-bit "words".  This code
 *      uses <stdint.h> (included via "sha1.h" to define 32 and 8
 *      bit unsigned integer types.  If your C compiler does not
 *      support 32 bit unsigned integers, this code is not
 *      appropriate.
 *
 *  Caveats:
 *      SHA-1 is designed to work with messages less than 2^64 bits
 *      long.  Although SHA-1 allows a message digest to be generated
 *      for messages of any number of bits less than 2^64, this
 *      implementation only works with messages with a length that is
 *      a multiple of the size of an 8-bit character.
 *
 */
function SHA1CircularShift(bits,word) {
	return ((word) << (bits)) | ((word) >>> (32-(bits)))
}
function SHA1Reset(context)
{
    context.Length_Low             = 0;
    context.Length_High            = 0;
    context.Message_Block_Index    = 0;
    context.Intermediate_Hash = new Uint32Array(Math.ceil(SHA1HashSize/4));
    context.Intermediate_Hash[0]   = 0x67452301;
    context.Intermediate_Hash[1]   = 0xEFCDAB89;
    context.Intermediate_Hash[2]   = 0x98BADCFE;
    context.Intermediate_Hash[3]   = 0x10325476;
    context.Intermediate_Hash[4]   = 0xC3D2E1F0;
    context.Computed   = 0;
    context.Corrupted  = 0;
	context.Message_Block = new Uint8Array(64);
	return shaSuccess;
}
function SHA1Result(context, Message_Digest)
{
	if (!context || !Message_Digest)
	{
		return shaNull;
	}
	if (context.Corrupted)
	{
		return context.Corrupted;
	}
	if (!context.Computed)
	{
		SHA1PadMessage(context);
		for(let i=0; i<64; ++i)
		{
			/* message may be sensitive, clear it out */
			context.Message_Block[i] = 0;
		}
		context.Length_Low = 0;    /* and clear length */
		context.Length_High = 0;
		context.Computed = 1;
	}
	for(let i = 0; i < SHA1HashSize; ++i)
	{
		Message_Digest[i] = context.Intermediate_Hash[i>>>2]
							>>> 8 * ( 3 - ( i & 0x03 ) );
	}
	return shaSuccess;
}
function SHA1Input(context, message_array, length=-1)
{
    if (typeof message_array === "string") message_array = message_array.toUint8Array();
    if (length == -1) length = message_array.length;
	if (!length)
	{
		return shaSuccess;
	}
	if (!context || !message_array)
	{
		return shaNull;
	}
	if (context.Computed)
	{
		context.Corrupted = shaStateError;
		return shaStateError;
	}
	if (context.Corrupted)
	{
		return context.Corrupted;
	}
	let message_array_index = 0
	while(length-- && !context.Corrupted)
	{
		context.Message_Block[context.Message_Block_Index++] = 
			message_array[message_array_index] & 0xFF;
		context.Length_Low += 8;
		if (context.Length_Low == 0)
		{
			context.Length_High++;
			if (context.Length_High == 0)
			{
				/* Message is too long */
				context.Corrupted = 1;
			}
		}
		if (context.Message_Block_Index == 64)
		{
			SHA1ProcessMessageBlock(context);
		}
		message_array_index++;
	}
	return shaSuccess;
}
function SHA1ProcessMessageBlock(context)
{
    const K = [       /* Constants defined in SHA-1   */
                            0x5A827999,
                            0x6ED9EBA1,
                            0x8F1BBCDC,
                            0xCA62C1D6
	];
    let      temp;              /* Temporary word value        */
    let      A, B, C, D, E;     /* Word buffers                */
	let      W = new Uint32Array(80);             /* Word sequence               */
	/*
     *  Initialize the first 16 words in the array W
     */
    for(let t = 0; t < 16; t++)
    {
        W[t] = context.Message_Block[t * 4] << 24;
        W[t] |= context.Message_Block[t * 4 + 1] << 16;
        W[t] |= context.Message_Block[t * 4 + 2] << 8;
        W[t] |= context.Message_Block[t * 4 + 3];
	}
    for(let t = 16; t < 80; t++)
    {
       W[t] = SHA1CircularShift(1,W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16]);
    }
    A = context.Intermediate_Hash[0];
    B = context.Intermediate_Hash[1];
    C = context.Intermediate_Hash[2];
    D = context.Intermediate_Hash[3];
    E = context.Intermediate_Hash[4];

    for(let t = 0; t < 20; t++)
    {
        temp =  SHA1CircularShift(5,A) +
                ((B & C) | ((~B) & D)) + E + W[t] + K[0];
        E = D;
        D = C;
        C = SHA1CircularShift(30,B);
        B = A;
        A = temp;
    }
    for(let t = 20; t < 40; t++)
    {
        temp = SHA1CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[1];
        E = D;
        D = C;
        C = SHA1CircularShift(30,B);
        B = A;
        A = temp;
    }
    for(let t = 40; t < 60; t++)
    {
        temp = SHA1CircularShift(5,A) +
               ((B & C) | (B & D) | (C & D)) + E + W[t] + K[2];
        E = D;
        D = C;
        C = SHA1CircularShift(30,B);
        B = A;
        A = temp;
    }
    for(let t = 60; t < 80; t++)
    {
        temp = SHA1CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[3];
        E = D;
        D = C;
        C = SHA1CircularShift(30,B);
        B = A;
        A = temp;
    }
    context.Intermediate_Hash[0] += A;
    context.Intermediate_Hash[1] += B;
    context.Intermediate_Hash[2] += C;
    context.Intermediate_Hash[3] += D;
    context.Intermediate_Hash[4] += E;
    context.Message_Block_Index = 0;
}
function SHA1PadMessage(context)
{
    /*
     *  Check to see if the current message block is too small to hold
     *  the initial padding bits and length.  If so, we will pad the
     *  block, process it, and then continue padding into a second
     *  block.
     */
    if (context.Message_Block_Index > 55)
    {
        context.Message_Block[context.Message_Block_Index++] = 0x80;
        while(context.Message_Block_Index < 64)
        {
            context.Message_Block[context.Message_Block_Index++] = 0;
        }
        SHA1ProcessMessageBlock(context);
        while(context.Message_Block_Index < 56)
        {
            context.Message_Block[context.Message_Block_Index++] = 0;
        }
    }
    else
    {
        context.Message_Block[context.Message_Block_Index++] = 0x80;
        while(context.Message_Block_Index < 56)
        {
            context.Message_Block[context.Message_Block_Index++] = 0;
        }
    }
    /*
     *  Store the message length as the last 8 octets
     */
    context.Message_Block[56] = context.Length_High >>> 24;
    context.Message_Block[57] = context.Length_High >>> 16;
    context.Message_Block[58] = context.Length_High >>> 8;
    context.Message_Block[59] = context.Length_High;
    context.Message_Block[60] = context.Length_Low >>> 24;
    context.Message_Block[61] = context.Length_Low >>> 16;
    context.Message_Block[62] = context.Length_Low >>> 8;
    context.Message_Block[63] = context.Length_Low;
    SHA1ProcessMessageBlock(context);
}

//------------------------------------------------------------------------
/*
 *  sha1test.c
 *
 *  Description:
 *      This file will exercise the SHA-1 code performing the three
 *      tests documented in FIPS PUB 180-1 plus one which calls
 *      SHA1Input with an exact multiple of 512 bits, plus a few
 *      error test checks.
 *
 *  Portability Issues:
 *      None.
 *
 */
function SHA1Test() {
    let sha = {};
    let str = " ";
    let Message_Digest = new Uint8Array(20);

    str="abc";
    SHA1Reset(sha);
    SHA1Input(sha, str.toUint8Array(),3);
    SHA1Result(sha, Message_Digest);
    console.log(Message_Digest.hexdump() == "a9993e364706816aba3e25717850c26c9cd0d89d");

    str="abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq";
    SHA1Reset(sha);
    SHA1Input(sha, str.toUint8Array());
    SHA1Result(sha, Message_Digest);
    console.log(Message_Digest.hexdump() == "84983e441c3bd26ebaae4aa1f95129e5e54670f1");

    str=new Array(1000000).fill(0).map(()=>"a").join("");
    SHA1Reset(sha);
    SHA1Input(sha, str.toUint8Array());
    SHA1Result(sha, Message_Digest);
    console.log(Message_Digest.hexdump() == "34aa973cd4c4daa4f61eeb2bdbad27316534016f");

    str=new Array(10*8).fill(0).map(()=>"01234567").join("");
    SHA1Reset(sha);
    SHA1Input(sha, str.toUint8Array());
    SHA1Result(sha, Message_Digest);
    console.log(Message_Digest.hexdump() == "dea356a2cddd90c7a7ecedc5ebb563934f460452");

    str="あいう";
    SHA1Reset(sha);
    SHA1Input(sha, "あいう".toUint8Array());
    SHA1Result(sha, Message_Digest);
    console.log(Message_Digest.hexdump() == "eb636ba7c320e00b3749ad404b7adc7609560dee");
}

//------------------------------------------------------------------------
String.prototype.toUint8Array = function() {
    let encStr = encodeURI(this);
    let i = 0;
    let result = [];
    while (i < encStr.length) {
        if (encStr[i] == '%') {
            result.push(parseInt(encStr[i+1] + encStr[i+2],16));
            i+=3;
        } else {
            result.push(encStr[i].charCodeAt(0));
            i++;
        }
    }
    return new Uint8Array(result);
}
Uint8Array.prototype.hexdump = function() {
    let hex = Array.from(this).map(n=>(`0${n.toString(16)}`.slice(-2)));
	return hex.join("");
}
function sha1_starts( ctx ) {SHA1Reset(ctx)}
function sha1_update( ctx, input, length ) {SHA1Input(ctx, input, length)}
function sha1_finish( ctx, digest ) {SHA1Result(ctx, digest)}

//------------------------------------------------------------------------
/*
 * This program is the JavaScript port of "randnum.c".
 * Copyright (C) 2018 hachisukansw
 *
 * randnum.c -- generate (good) randum numbers.
 *
 * Copyright (C) 2001,2002 by Theodore Ts'o
 * 
 * This file may be distributed under the terms of the GNU Public
 * License.
 */

/*
 * Generate a random number n, where 0 <= n < max_num, using
 * window.crypto.getRandomValues possible.
 */
function pw_random_number(max_num)
{
	if (typeof window != "undefined" && window.crypto) {
		let rand_num = window.crypto.getRandomValues(new Uint32Array(1))[0];
		return (rand_num % max_num);
	}
	return Math.floor(Math.random() * max_num);
}
//------------------------------------------------------------------------
/*
 * This program is the JavaScript port of "sha1num.c".
 * Copyright (C) 2018 hachisukansw
 *
 * sha1num.c --- generate sha1 hash based, pseudo random numbers
 *
 * Copyright (C) 2005 by Olivier Guerrier
 *
 * This file may be distributed under the terms of the GNU Public
 * License.
 */
let sha1_ctx = {};
let sha1_seed = "";
const sha1_magic = "pwgen";
let sha1sum = new Uint8Array(20);
let sha1sum_idx = 20;
	
function pw_sha1_init(sha1)
{
	if (/^(.+)[:#](.+)$/.test(sha1)) {
		sha1_seed = RegExp.$2;
		sha1 = RegExp.$1;
	} else {
		sha1_seed = sha1_magic;
	}
	sha1_ctx = {};
	sha1sum = new Uint8Array(20);
	sha1sum_idx = 20;
	sha1_starts( sha1_ctx );
	sha1_update( sha1_ctx, sha1);
	return;
}


function pw_sha1_number(max_num)
{
	if (sha1sum_idx>19) {
		sha1sum_idx = 0;
		sha1_update(sha1_ctx, sha1_seed.toUint8Array());
		let ctx = JSON.parse(JSON.stringify(sha1_ctx));
		sha1_finish(ctx, sha1sum );
	}
	let val = Math.floor(( sha1sum[sha1sum_idx++] / 256) * max_num);
	return val;
}

//------------------------------------------------------------------------
/*
 * This program is the JavaScript port of "pwgen.c".
 * Copyright (C) 2018 hachisukansw
 *
 * pwgen.c --- generate secure passwords
 *
 * Copyright (C) 2001,2002 by Theodore Ts'o
 * 
 * This file may be distributed under the terms of the GNU Public
 * License.
 */
/* Program parameters set via getopt */

const pwgen_options = {
		"--alt-phonics": "-a",
		"--capitalize": "-c",
		"--numerals": "-n",
		"--symbols": "-y",
		"--num-passwords":  "-N",
		"--remove-chars":  "-r",
		"--secure": "-s",
		"--help": "-h",
		"--no-numerals": "-0",
		"--no-capitalize": "-A",
		"--sha1": "-H",
		"--ambiguous": "-B",
		"--no-vowels": "-v",
		"--length": "-L",
}

const usage_en = ""
	+"Usage: pwgen [ OPTIONS ] [ pw_length ] [ num_pw ]\n\n"
	+"Options supported by pwgen:\n"
	+"  -c or --capitalize\n"
	+"\tInclude at least one capital letter in the password\n"
	+"  -A or --no-capitalize\n"
	+"\tDon't include capital letters in the password\n"
	+"  -n or --numerals\n"
	+"\tInclude at least one number in the password\n"
	+"  -0 or --no-numerals\n"
	+"\tDon't include numbers in the password\n"
	+"  -y or --symbols\n"
	+"\tInclude at least one special symbol in the password\n"
	+"  -r <chars> or --remove-chars=<chars>\n"
	+"\tRemove characters from the set of characters to "
	+"generate passwords\n"
	+"  -s or --secure\n"
	+"\tGenerate completely random passwords\n"
	+"  -B or --ambiguous\n"
	+"\tDon't include ambiguous characters in the password\n"
	+"  -h or --help\n"
	+"\tPrint a help message\n"
	+"  -H or --sha1=text[:seed]\n"
	+"\tUse sha1 hash of given text as a (not so) random generator\n"
	+"  -C\n\tPrint the generated passwords in columns\n"
	+"  -1\n\tDon't print the generated passwords in columns\n"
	+"  -v or --no-vowels\n"
	+"\tDo not use any vowels so as to avoid accidental nasty words\n";

const usage_ja = ""
	+"Usage: pwgen [ OPTIONS ] [ pw_length ] [ num_pw ]\n\n"
	+"pwgenでサポートされるオプション:\n"
	+"  -c or --capitalize\n"
	+"\tパスワードに少なくとも1つの大文字を含める（デフォルト）\n"
	+"  -A or --no-capitalize\n"
	+"\tパスワードに大文字を含めない\n"
	+"  -n or --numerals\n"
	+"\tパスワードに少なくとも1つの数字を含める（デフォルト）\n"
	+"  -0 or --no-numerals\n"
	+"\tパスワードに数字を含めない\n"
	+"  -y or --symbols\n"
	+"\t少なくとも1つの特別な記号をパスワードに含める\n"
	+"  -r <chars> or --remove-chars=<chars>\n"
	+"\t指定された文字を削除してパスワードを生成する\n"
	+"  -s or --secure\n"
	+"\t完全にランダムなパスワードを生成する\n"
	+"  -B or --ambiguous\n"
	+"\tあいまいな文字をパスワードに含めない\n"
	+"  -h or --help\n"
	+"\tヘルプメッセージを表示する\n"
	+"  -H or --sha1=text[:seed]\n"
	+"\t与えられたテキストのsha1ハッシュを（そうではない）ランダムジェネレータとして使用する\n"
	+"  -C\n\t生成されたパスワードを列表示する（デフォルト）\n"
	+"  -1\n\t生成されたパスワードを列表示しない\n"
	+"  -v or --no-vowels\n"
	+"\t母音を使用しない\n";

function usage() {
	return usage_ja;
}

function get_opt(strOpt)
{
	let locParams = ["--length", "--num-passwords"];
	let opt = {};
	strOpt = strOpt.replace(/^.*\?/,"");
	for (let s of strOpt.split('&')) {
		let [key,value] = s.split('=');
		if (key == "") continue;
		if (!value) value = "";
		if (!/^\-/.test(key) && value == "" && locParams.length > 0) {
			value = key;
			key = locParams.shift();
		}
		if (key in pwgen_options) key = pwgen_options[key];
		if (/^\-([0-9a-zA-Z]+)$/.test(key)) {
			let keys = RegExp.$1.split("");
			opt[`-${keys.pop()}`] = value;
			for (let key of keys) {
				opt[`-${key}`] = ""
			}
		} else {
			opt[key] = value;
		}
	}
	return opt;
}
function main(opt)
{
	if (arguments.length == 0) opt = {};
	if (typeof opt == "string") opt = get_opt(opt);

	let pw_length = 8;
	let num_pw = -1;
	let pwgen_flags = 0;
	let	remove = "";
	let pwgen = pw_phonemes;

	let	num_cols = -1;
	let	term_width = 80;
	let	do_columns = 1;
	let pw_number = pw_random_number;

	pwgen_flags |= PW_DIGITS | PW_UPPERS;

	if ("-0" in opt) pwgen_flags &= ~PW_DIGITS;
	if ("-A" in opt) pwgen_flags &= ~PW_UPPERS;
	if ("-a" in opt);
	if ("-B" in opt) pwgen_flags |= PW_AMBIGUOUS;
	if ("-c" in opt) pwgen_flags |= PW_UPPERS;
	if ("-n" in opt) pwgen_flags |= PW_DIGITS;
	if ("-N" in opt) {
			num_pw = parseInt(opt["-N"]);
			if (isNaN(num_pw)) {
				do_columns = 0;
				return [`Invalid number of passwords: ${opt["-N"]}`];
			}
	}
	if ("-s" in opt) pwgen = pw_rand;
	if ("-C" in opt) do_columns = 1;
	if ("-1" in opt) do_columns = 0;
	if ("-H" in opt) {
			pw_sha1_init(opt["-H"]);
			pw_number = pw_sha1_number;
	}
	if ("-y" in opt) pwgen_flags |= PW_SYMBOLS;
	if ("-v" in opt) {
			pwgen = pw_rand;
			pwgen_flags |= PW_NO_VOWELS;
	}
	if ("-r" in opt) {
			remove = opt["-r"];
			pwgen = pw_rand;
	}
	if (("-h" in opt) || ("-?" in opt)) {
		do_columns = 0;
		return usage().split("\n");
	}

	if ("-L" in opt) {
		pw_length = parseInt(opt["-L"]);
		if (isNaN(pw_length)) {
			do_columns = 0;
			return [`Invalid password length: ${opt["-L"]}`]
		}
		if (pw_length < 5)
			pwgen = pw_rand;
		if (pwgen != pw_rand) {
			if (pw_length <= 2)
				pwgen_flags &= ~PW_UPPERS;
			if (pw_length <= 1)
				pwgen_flags &= ~PW_DIGITS;
		}
	}

	num_cols = -1;
	if (do_columns) {
		num_cols = Math.floor(term_width / (pw_length+1));
		if (num_cols == 0)
			num_cols = 1;
	}
	if (num_pw < 0)
		num_pw = do_columns ? num_cols * 20 : 1;
	
	let lines = "";
	for (let i=0; i < num_pw; i++) {
		let buf = pwgen(pw_length, pwgen_flags, remove, pw_number);
		if (!do_columns || ((i % num_cols) == (num_cols-1)) ||
		    (i == (num_pw - 1)))
			lines += buf + "\n";
		else
			lines += buf + " ";
	}

	return lines;
}

</script>

<script>
'use strict'
class Opt {
	constructor(url) {
		this.registObj({
			"pw_length": 8,
			"num_pw": -1,
			"pwgen_flags": PW_DIGITS | PW_UPPERS,
			"remove_chars": "",
			"pwgen_func": pw_phonemes,
			"do_columns": 1,
			"pw_number": pw_random_number,
			"pw_length": 8,
			"do_help": false,
			"num_cols": -1,
			"term_width": 80,
		});
		if (arguments.length == 1) this.fromUrl(url);  
	}
	longname_options() {
		return pwgen_options();
	}
	fromUrl(url) {
		if (arguments.length == 0) url = window.location.search;
		let opt = this.parseUrl(url);
		this.parseOpt(opt);
		this.registObj(opt);
	}
	parseUrl(url) {
		return get_opt(url);
	}
	registObj(obj) {
		for (let key in obj) {
			this[key] = obj[key];
		}
	}
	parseOpt(opt) {
		this.pw_length = 8;
		this.num_pw = -1;
		this.pwgen_flags = PW_DIGITS | PW_UPPERS;
		this.remove_chars =  "";
		this.pwgen_func = pw_phonemes;
		this.do_columns = 1;
		this.pw_number = pw_random_number;
		this.pw_length = 8;
		this.do_help = false;
		this.num_cols = 1;
		//this.term_width = 80;

		if ("-0" in opt) this.pwgen_flags &= ~PW_DIGITS;
		if ("-A" in opt) this.pwgen_flags &= ~PW_UPPERS;
		if ("-a" in opt);
		if ("-B" in opt) this.pwgen_flags |= PW_AMBIGUOUS;
		if ("-c" in opt) this.pwgen_flags |= PW_UPPERS;
		if ("-n" in opt) this.pwgen_flags |= PW_DIGITS;
		if ("-N" in opt) {
				this.num_pw = parseInt(opt["-N"]);
				if (isNaN(this.num_pw)) return;
		}
		if ("-s" in opt) this.pwgen_func = pw_rand;
		if ("-C" in opt) this.do_columns = true;
		if ("-1" in opt) this.do_columns = false;
		if ("-H" in opt) this.pw_number = pw_sha1_number;
		if ("-y" in opt) this.pwgen_flags |= PW_SYMBOLS;
		if ("-v" in opt) {
				this.pwgen_func = pw_rand;
				this.pwgen_flags |= PW_NO_VOWELS;
		}
		if ("-r" in opt) {
				this.remove_chars = opt["-r"];
				this.pwgen_func = pw_rand;
		}
		if (("-h" in opt) || ("-?" in opt)) {
				this.do_help = true;
		}
	
		if ("-L" in opt) {
			this.pw_length = parseInt(opt["-L"]);
			if (isNaN(this.pw_length)) return;
			if (this.pw_length < 5)
				this.pwgen_func = pw_rand;
			if (this.pwgen_func != pw_rand) {
				if (this.pw_length <= 2)
					this.pwgen_flags &= ~PW_UPPERS;
				if (this.pw_length <= 1)
					this.pwgen_flags &= ~PW_DIGITS;
			}
		}

		if ("--term-width" in opt) this.term_width = parseInt(opt["--term-width"]);

		if (this.do_columns) {
			this.num_cols = Math.floor(this.term_width / (this.pw_length + 1));
			if (this.num_cols == 0)
				this.num_cols = 1;
		}

		if (this.num_pw < 0) {
			this.num_pw = this.do_columns ? this.num_cols * 20 : 1;
		}
	}
}
class Password {
	constructor() {
		this._list = [];
		this._opt = {};
	}
	list() {
		return this._list;
	}
	generate(opt) {
		this._opt = opt;
		if (opt.do_help) {
			this._list = [usage()];
			return;
		}
		if (isNaN(opt.num_pw)) {
			this._list = [`Invalid number of passwords: ${opt["-N"]}`];
			return;
		}
		if (isNaN(opt.pw_length)) {
			this._list = [`Invalid password length: ${opt["-L"]}`];
			return;
		}
		if (opt.pw_number === pw_sha1_number) pw_sha1_init(opt["-H"]);
		this._list = [];
		while (this._list.length < opt.num_pw) {
			this._list.push(opt.pwgen_func(opt));
		}
		this.filter();
	}
	filter() {
		let opt = this._opt;
		if ("--uniq" in opt) {
			let new_list = [];
			for (let pw of this._list) {
				if (!new_list.includes(pw)) new_list.push(pw);
			}
			this._list = new_list;
		}
		if ("--grep-upper" in opt) this._list = this._list.filter(pw=>(/[A-Z]/.test(pw)));
		if ("--grep-lower" in opt) this._list = this._list.filter(pw=>(/[a-z]/.test(pw)));
		if ("--grep-digit" in opt) this._list = this._list.filter(pw=>(/[0-9]/.test(pw)));
		if ("--grep-punct" in opt) {
			this._list = this._list.filter(pw=>pw.split("").filter(s=>pw_symbols.includes(s)).length>0);
		}
	}
	toString() {
		let opt = this._opt;
		let lines = [];
		lines.unshift([]);
		for (let pw of this._list) {
			if (lines[0].length >= opt.num_cols) lines.unshift([]);
			lines[0].push(pw);
		}
		return lines.map(line=>line.join(" ")).reverse().join("\n");
	}
}
class UI {
	constructor() {
		this._elements = {};
		this.registElements();
	}
	elements() {
		return this._elements;
	}
	registElements() {
		for (let o of Array.from(document.getElementsByTagName('*'))) {
			if (!o.id) continue;
			this._elements[o.id] = o
		}
		for (let key in this._elements) {
			this[key] = this._elements[key];
		}
	}
	fromOpt(opt) {
		for (let o of Object.values(this._elements)) {
			if (o.tagName != "INPUT") continue;
			if (o.type == "text") {
				o.value = "";
			} else if (o.type == "checkbox") {
				o.checked = false;
			}
		}
		for (let key in opt) {
			if (!(key in this._elements)) continue;
			this._elements[key].checked = true;
			if (!(`${key}_txt` in this._elements)) continue;
			this._elements[`${key}_txt`].value = opt[key];
		}
	}
	fromUrl(url) {
		if (arguments.length == 0) url = window.location.search;
		this.fromOpt(new Opt(url));
	}
	toArray() {
		let result = [];
		for (let o of Object.values(this._elements)) {
			if (!o.checked) continue;
			if (!/^-/.test(o.id)) continue;
			if ((`${o.id}_txt` in this._elements)) {
				if (this._elements[`${o.id}_txt`].value == "") continue;
				result.push(`${o.id}=${this._elements[`${o.id}_txt`].value}`);
			} else {
				result.push(o.id);
			}
		}
		result.push(`--term-width=${this.computeTermWidth()}`);
		return result;
	}
	toString() {
		return this.toArray().join("&");
	}
	toOpt() {
		return new Opt(this.toString());
	}
	showPassword(passwords) {
		this["result"].value = passwords.toString();
		this["status"].textContent = `count: ${passwords.list().length}`;
	}
	computeTermWidth() {
		let check_element = this["result"];
		let backup = {};
		backup["text"] = check_element.value;
		backup["overflow-y"] = window.getComputedStyle(check_element,null)["overflow-y"];
		check_element.style.overflowY = "scroll";
		let max = 1000;
		let min = 0
		let m;
		while (max >= min) {
			m = min + Math.floor((max - min) / 2);
			check_element.value = new Array(m).fill("A").join("");
			if (check_element.scrollWidth > check_element.clientWidth) {
				max = m - 1;
			} else {
				min = m + 1
			}
		}
		check_element.style.overflowY = backup["overflow-y"];
		check_element.value = backup["text"];
		return m - 1;
	}
}

let ui = new UI();
let pw = new Password();

function refresh() {
	pw.generate(ui.toOpt());
	ui.showPassword(pw);
}

ui.fromUrl();
refresh();

for (let o of Object.values(ui.elements())) {
	if (o.type == "checkbox") o.addEventListener("change", e=>refresh());
	if (o.type == "text") o.addEventListener("input", e=>refresh());
}
ui["refresh"].addEventListener("click", e=>refresh());

</script>
</html>
